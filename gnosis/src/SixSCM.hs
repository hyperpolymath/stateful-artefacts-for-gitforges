{- |
Module      : SixSCM
Description : Load all 6 SCM files (STATE, ECOSYSTEM, META, NEUROSYM, AGENTIC, PLAYBOOK)
Copyright   : (c) 2025-2026 Jonathan D.A. Jewell
License     : PMPL-1.0-or-later
Maintainer  : hyperpolymath

The 6scm standard consists of 6 Scheme metadata files that provide
complete project context. This module loads all 6 and merges their
contexts for template rendering.
-}

module SixSCM
    ( loadAll6SCM
    , SCMFiles(..)
    , defaultSCMPath
    ) where

import qualified Data.Map.Strict as Map
import System.Directory (doesFileExist)
import System.FilePath ((</>))
import Types (Context, FlexiText(..))
import SExp (SExp, parseSExp, findInTree)

-- | The 6 SCM files
data SCMFiles = SCMFiles
    { stateFile     :: Maybe FilePath
    , ecosystemFile :: Maybe FilePath
    , metaFile      :: Maybe FilePath
    , neurosymFile  :: Maybe FilePath
    , agenticFile   :: Maybe FilePath
    , playbookFile  :: Maybe FilePath
    } deriving (Show, Eq)

-- | Default paths for 6scm files
defaultSCMPath :: FilePath
defaultSCMPath = ".machine_readable"

-- | Default 6scm files configuration
default6SCMFiles :: FilePath -> SCMFiles
default6SCMFiles basePath = SCMFiles
    { stateFile     = Just (basePath </> "STATE.scm")
    , ecosystemFile = Just (basePath </> "ECOSYSTEM.scm")
    , metaFile      = Just (basePath </> "META.scm")
    , neurosymFile  = Just (basePath </> "NEUROSYM.scm")
    , agenticFile   = Just (basePath </> "AGENTIC.scm")
    , playbookFile  = Just (basePath </> "PLAYBOOK.scm")
    }

-- | Load all 6 SCM files and merge contexts
loadAll6SCM :: FilePath -> IO Context
loadAll6SCM basePath = do
    let files = default6SCMFiles basePath

    -- Load each file that exists
    stateCtx     <- loadSCMFile (stateFile files)
    ecosystemCtx <- loadSCMFile (ecosystemFile files)
    metaCtx      <- loadSCMFile (metaFile files)
    neurosymCtx  <- loadSCMFile (neurosymFile files)
    agenticCtx   <- loadSCMFile (agenticFile files)
    playbookCtx  <- loadSCMFile (playbookFile files)

    -- Merge contexts (later files override earlier)
    return $ Map.unions
        [ playbookCtx   -- Highest priority
        , agenticCtx
        , neurosymCtx
        , metaCtx
        , ecosystemCtx
        , stateCtx      -- Lowest priority (first loaded)
        ]

-- | Load a single SCM file and extract context
loadSCMFile :: Maybe FilePath -> IO Context
loadSCMFile Nothing = return Map.empty
loadSCMFile (Just path) = do
    exists <- doesFileExist path
    if not exists
        then return Map.empty
        else do
            content <- readFile path
            case parseSExp content of
                Nothing -> return Map.empty
                Just tree -> return $ extractContext tree

-- | Extract context from S-expression tree
-- Looks for common keys and creates FlexiText pairs
extractContext :: SExp -> Context
extractContext tree = Map.fromList
    [ ("name", mkFlexiText "name" (findInTree "name" tree))
    , ("mood", mkFlexiText "mood" (findInTree "mood" tree))
    , ("version", mkFlexiText "version" (findInTree "version" tree))
    , ("phase", mkFlexiText "phase" (findInTree "phase" tree))
    , ("compliance", mkFlexiText "compliance-level" (findInTree "compliance-level" tree))
    , ("compliance-level", mkFlexiText "compliance-level" (findInTree "compliance-level" tree))
    , ("health", mkFlexiText "health-score" (findInTree "health-score" tree))
    , ("health-score", mkFlexiText "health-score" (findInTree "health-score" tree))
    , ("repo-count", mkFlexiText "repo-count" (findInTree "repo-count" tree))
    , ("language-count", mkFlexiText "language-count" (findInTree "language-count" tree))
    , ("star-count", mkFlexiText "star-count" (findInTree "star-count" tree))
    , ("active-count", mkFlexiText "active-count" (findInTree "active-count" tree))
    , ("last-updated", mkFlexiText "last-updated" (findInTree "last-updated" tree))
    , ("current-focus", mkFlexiText "current-focus" (findInTree "current-focus" tree))
    , ("current-phase", mkFlexiText "current-phase" (findInTree "current-phase" tree))
    , ("engine", FlexiText "Gnosis" "Engine: Gnosis (Haskell)")
    , ("generator", FlexiText "Gnosis/Haskell" "Generated by Gnosis Haskell engine")
    ]
  where
    mkFlexiText :: String -> Maybe String -> FlexiText
    mkFlexiText key Nothing = FlexiText "unknown" (key ++ ": unknown")
    mkFlexiText key (Just val) = FlexiText val (key ++ ": " ++ val)
